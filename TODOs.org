* Notes for a refactor

- In ~_attempt_spawn~ we accumulate data both for successful and unsuccessful diagram generation.
- In ~_store_new_val~, we check whether to store based on the absolute value of the amplitude.
  Questions:
  * Shouldn't this be the responsibility of the store?
  * Preconditioning. Could probably become responsibility of the store too.
  * Initiator vs. non-initiator. Logic is hard to follow...
  * Why would we _not always_ want to store spawn statistics? Now we pass the diagram around, though it is actually only needed in ~_attempt_spawn~.
- The ~Cluster~ data structure should be constructible from a list of excitors.
- Communications hub. Use ~pathlib~ to open, read, remove files.
- Fix ~TimeParamType~ regex. Charlie found
  ~r'((?P<days>\d{2})-)?(?P<hours>\d{2,3}):(?P<minutes>\d{2})(:(?P<seconds>\d{2}))?'~
- Reblocking from zarr while running. We need to check whether file is open to
  avoid resource contention. If open read data up to point where nonsense
  starts.
- zarr storage and calculation restarts in an interactive session.
- ~ImportanceSamplingStore~ we only need ~combo_store~ from the wavefunction during set up.

* Scattered notes

- In the even selection paper the "trick" is to first count number of "combos"
  and then normalize to some condition. This obtains the discrete probability
  distributions to sample.
- We have two types of granularity:
  a. \(\gamma\): the *evaluation* granularity. Decides magnitude of diagrams to sample.
  b. \(\Delta\): the *representation* granularity. Decides rounding of values to store.
- "There are no particles, only fields." or for us "There are no particles, only granularities."

* Random number generation

- In Rust: https://rust-random.github.io/book/guide-rngs.html
- ~WeightedIndex~ in the ~rand~ crate implements the alias method: https://rust-random.github.io/rand/rand/distributions/weighted/alias_method/struct.WeightedIndex.html
- The Python ~randomgen~ package is the next generation collection of RNGs for NumPy: https://bashtage.github.io/randomgen/index.html
- The xoshiro/xoroshiro RNGs seem to be the most efficient: http://prng.di.unimi.it/ The website has notes on how to generate good seeds.

* Optimization

- Radovan ran cProfile on the code and found the following: https://gist.github.com/bast/cda2650bf47bba9ba049ae3b6d33fe57
- The profile was obtained with the procedure documented here: https://github.com/bast/cprofile-howto

* TODO Debugging notes
  - [ ] The trial loop in MCCrust differs from diagCCMC: we look for all
    excitations allowed in the selected truncation level, but really we should
    only look at the ones allowed in the MP1 initialisation (doubles only)
